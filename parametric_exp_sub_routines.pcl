# Return a 2d-array. One states the interval index, another states whether it is deviant
sub 
	array<int,2> assignDeviant(int interval_cond, array<int> index_of_whole_block[])
begin
	#initialize the array going to be returned
	array <int> stim_list[2][setting_interval_in_block]; # 2 elements


	# create the list of whether this is deviant of this block (1 = deviant, 0 = standard)
	array <int> whether_deviant[setting_interval_in_block];
	# initialize it to be all zeros
	whether_deviant.fill(1, whether_deviant.count(),0,0);

	# assign 96 deviant to it
	# initialize a counter of an interval being deviant
	array <int> counter_deviant[interval_cond]; # [1] will store the number of time of the 1st interval, [2] stores 2nd interval...
	int max_time_being_deviant = setting_deviant_in_block/interval_cond; # the maximum number of time of each interval being a deviant

	loop int i = 1 until i > setting_deviant_in_block begin # for each deviant
		
		# try to insert it to a random position. Insert will only be successful when all conditions met
		loop bool insert_successful = false until insert_successful == true begin
			# get a random index for inserting the deviant
			int insert_position = random(1, setting_interval_in_block); 
			
			#only turn it to deviant when it is not one yet. The backward and forward 3 trials should not be deivant
			bool have_deviant_forward_backward = false;
			int num_backward_forward = setting_deviant_min_trial_apart;
			loop int j = 1 until j > num_backward_forward begin
				if insert_position + j <= setting_interval_in_block then # check whether it is out of bound
					if whether_deviant[insert_position + j] == 1 then
						have_deviant_forward_backward = true;
						break;
					end;
				end;
				
				if insert_position - j >= 1 then # check whether it is out of bound
					if whether_deviant[insert_position - j] == 1 then
						have_deviant_forward_backward = true;
						break;
					end;
				end; 
				
				j = j + 1;
			end;#end of looping backward / forward
			
			if whether_deviant[insert_position] == 0 && have_deviant_forward_backward == false then 
				int insert_target_stim_index = index_of_whole_block[insert_position]; # get which stimulus this trial is
				# check the counter array to see whether this stim not yet exceed maximum deviant num
				if counter_deviant[insert_target_stim_index] < max_time_being_deviant then
					whether_deviant[insert_position] = 1;
					counter_deviant[insert_target_stim_index] = counter_deviant[insert_target_stim_index] +1;
					insert_successful = true;
				end; # end of if the stim not yet exceed max time
			end; # end of if position is 0
		end;
		
		i = i + 1;
	end;

	stim_list[1] = index_of_whole_block;
	stim_list[2] = whether_deviant;
	
	term.print_line(counter_deviant);
	
	return(stim_list);
end; # END OF assignDeviant


# create the list of stimuli of all trials in this block according to the regular_cond and interval_cond
# regular_cond (1: regular, 2: irregular)
# interval_cond (1, 2, 4, 16)
sub
	array<int,1> getBlockStimList(int regular_cond, int interval_cond)
begin
	# initialize a result variable
	array <int> stim_index_of_whole_block[0];

	# get the according regular order list based on the condition
	array <int> regular_order_list[0];
	if interval_cond == 1 then
		regular_order_list.append(order_1intervals);
	end;
	if interval_cond == 2 then
		regular_order_list.append(order_2intervals);
	end;
	if interval_cond == 4 then
		regular_order_list.append(order_4intervals);
	end;
	if interval_cond == 16 then
		regular_order_list.append(order_16intervals);
	end;

	if regular_cond == 1 then
		loop int i = 1 until i > (setting_interval_in_block / interval_cond) begin # the sequence will repeat for [480 / 4 intervals] times
			stim_index_of_whole_block.append(regular_order_list);
			i = i+1;
		end;
	end; # END OF regular_cond==1

	# for irregular condition, the same pattern should not repeat more than 3 times (3 time is allowed)
	if regular_cond == 2 then

		# initialize variable for checking
		array <int> last_sequence[0];
		int same_pattern_counter = 1;

		loop int i = 1 until i > (setting_interval_in_block / interval_cond) begin
			array <int> this_sequence[] = regular_order_list;
			this_sequence.shuffle();

			if last_sequence.count() != 0 && this_sequence == last_sequence then
				same_pattern_counter = same_pattern_counter + 1;
				if same_pattern_counter > setting_maximum_same_pattern then
					loop until this_sequence != last_sequence begin
						this_sequence.shuffle();
					end;
					same_pattern_counter = 1;
				end;

			else
				same_pattern_counter = 1;
			end;
			#term.print(same_pattern_counter);term.print(",");

			stim_index_of_whole_block.append(this_sequence);

			last_sequence.assign(this_sequence);
			i = i + 1;
		end;
	end; # END of regular_cond == 2

	return(stim_index_of_whole_block);

end;


# a routine to set the sound stimulus in each trial
# it will also return the wav file duration
sub 
	double setSoundStim(int deviant_cond, array<sound,1> normal_sound, array<sound,1> rotate_sound, int stim_id, int is_deviant) 
begin
	
	# should always be active so that false alarm / hit can be recorded
	
	sound the_stim;

	# rotate as deviant
	if deviant_cond == 1 && is_deviant == 0 then
		the_stim = normal_sound[stim_id];
	end;
	if deviant_cond == 1 && is_deviant == 1 then
		the_stim = rotate_sound[stim_id]
	end;

	# rotate as normal
	if deviant_cond == 2 && is_deviant == 0 then
		the_stim = rotate_sound[stim_id]
	end;
	if deviant_cond == 2 && is_deviant == 1 then
		the_stim = normal_sound[stim_id];
	end;

	sound_event.set_stimulus(the_stim);
	sound_event.set_target_button(is_deviant); # when it is not deviant, the target button should set to 0; when it is deviant, target button set to 1;
	if is_deviant == 1 then
		sound_event.set_stimulus_time_in(setting_response_window_start);
		sound_event.set_stimulus_time_out(setting_response_window_end);
	end;

	return(the_stim.get_wavefile().duration())

end;

# -- Present General Instruction --
# A sub to present general insturction for whatever string
sub
	presentGeneralInstruct(string displayText)
begin
	instruct.set_caption(displayText);
	instruct.redraw();
	instruct_trial.present();
end;

# a routine for setting the event code and port code of the stimulus event
# event code is for logging to the log file
# port code is for logging to the EEG port (value of port_code must be an integer between and including 0 and 2147483647)
sub
	setEventCode_PortCode(int counterbalance_id, int stim_id, double wav_duration, int deviant_cond, int regular_cond, int interval_cond, int is_deviant)
begin
	string my_event_code;
	string my_port_code;

	# change 1,2,4,16 interval_cond to 1,2,4,9
	int interval_cond_one_digit = interval_cond; 
	if interval_cond_one_digit == 16 then interval_cond_one_digit = 9; end;
	# add a 0 for one-digit stim_id
	string stim_id_str;
	if stim_id < 10 then stim_id_str = "0" + string(stim_id); end;	
	if stim_id >= 10 then stim_id_str = string(stim_id); end;

	# port code
	my_port_code = my_port_code + string(deviant_cond); # first digit is deviant cond
	my_port_code = my_port_code + string(regular_cond); # second digit is regular cond
	my_port_code = my_port_code + string(interval_cond_one_digit); #thrid digit is the interval condition
	my_port_code = my_port_code + string(is_deviant); # forth digit is whether this is deviant (0 = no, 1 = yes)
	my_port_code = my_port_code + stim_id_str; # last 2 digits are stim_id (01 = first stim, 16 = last stim) 

	# event code
	my_event_code =  my_event_code + string(counterbalance_id) + ";" ;
	my_event_code = my_event_code + string(stim_id) + ";" ;
	my_event_code = my_event_code + string(wav_duration) + ";" ;
	my_event_code = my_event_code + "main" + ";" ;
	my_event_code = my_event_code + string(deviant_cond) + ";" ;
	my_event_code = my_event_code + string(regular_cond) + ";" ;
	my_event_code = my_event_code + string(interval_cond) + ";" ;
	my_event_code = my_event_code + string(is_deviant) + ";" ;
	my_event_code = my_event_code + "blockIndex" + ";" ;
	my_event_code = my_event_code + string(int(my_port_code)) + ";" ;

	sound_event.set_event_code(my_event_code);
	sound_event.set_port_code(int(my_port_code));

end;


# the routine to run the block given different conditions
sub
	runBlock(int deviant_cond, int regular_cond, int interval_cond, int counterbalance_id)
begin

	##### Things to set before the whole block starts #####
	array <int> this_block_stim_list[] = getBlockStimList(regular_cond, interval_cond);
	array <int> this_block_stim_deviant[][] = assignDeviant(interval_cond, this_block_stim_list);

	# Find the according sound files of this interval_cond
	array <sound> normal_sound[0];
	array <sound> rotate_sound[0];
	if interval_cond == 1 then normal_sound.assign(soundfiles_1intervals); rotate_sound.assign(soundfiles_1intervals_rotated); end;
	if interval_cond == 2 then normal_sound.assign(soundfiles_2intervals); rotate_sound.assign(soundfiles_2intervals_rotated); end;
	if interval_cond == 4 then normal_sound.assign(soundfiles_4intervals); rotate_sound.assign(soundfiles_4intervals_rotated); end;
	if interval_cond == 16 then normal_sound.assign(soundfiles_16intervals); rotate_sound.assign(soundfiles_16intervals_rotated); end;

	##### END OF Things to set before the whole block starts #####

	# loop through trials
	loop int i = 1 until i > this_block_stim_list.count() begin
		double wav_file_duration = setSoundStim(deviant_cond, normal_sound, rotate_sound, this_block_stim_deviant[1][i], this_block_stim_deviant[2][i]);
		setEventCode_PortCode(counterbalance_id, this_block_stim_deviant[1][i], wav_file_duration, deviant_cond, regular_cond, interval_cond, this_block_stim_deviant[2][i]);
		
		sound_trial.present();
		i = i + 1;
	end; 
	
end;


# a routine to run experiment based on the input id
sub
	runExperiment(int counterbalance_id)
begin
	# get this participant order based on his id
	array<int> user_deviant_block_order_list[] = setting_deviant_order[cbtable_deviant_order[counterbalance_id]];
	array<int> user_regular_block_order_list[] = setting_regular_order[cbtable_regular_order[counterbalance_id]];
	array<int> user_interval_block_order_list[] = setting_interval_order[cbtable_interval_order[counterbalance_id]];

	loop int deviant_block_counter = 1 until deviant_block_counter > user_deviant_block_order_list.count() begin
	
		loop int regular_block_counter = 1 until regular_block_counter > user_regular_block_order_list.count() begin
		
			loop int interval_block_counter = 1 until interval_block_counter > user_interval_block_order_list.count() begin

				runBlock(user_deviant_block_order_list[deviant_block_counter],
				user_regular_block_order_list[regular_block_counter],
				user_interval_block_order_list[interval_block_counter],
				counterbalance_id);



				interval_block_counter = interval_block_counter + 1;
			end; # end of loop interval block
		
		regular_block_counter = regular_block_counter + 1;
		end; # end of loop regular block

		deviant_block_counter = deviant_block_counter+1;
	end; # end of loop deviant block

end;

