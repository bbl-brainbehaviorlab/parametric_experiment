# Return a 2d-array. One states the interval index, another states whether it is deviant
sub 
	array<int,2> assignDeviant(int interval_cond, array<int> index_of_whole_block[])
begin
	#initialize the array going to be returned
	array <int> stim_list[2][setting_interval_in_block]; # 2 elements


	# create the list of whether this is deviant of this block (1 = deviant, 0 = standard)
	array <int> whether_deviant[setting_interval_in_block];
	# initialize it to be all zeros
	whether_deviant.fill(1, whether_deviant.count(),0,0);

	# assign 96 deviant to it
	# initialize a counter of an interval being deviant
	array <int> counter_deviant[interval_cond]; # [1] will store the number of time of the 1st interval, [2] stores 2nd interval...
	int max_time_being_deviant = setting_deviant_in_block/interval_cond; # the maximum number of time of each interval being a deviant

	loop int i = 1 until i > setting_deviant_in_block begin # for each deviant
		
		# try to insert it to a random position. Insert will only be successful when all conditions met
		loop bool insert_successful = false until insert_successful == true begin
			# get a random index for inserting the deviant
			int insert_position = random(1, setting_interval_in_block); 
			
			#only turn it to deviant when it is not one yet. The backward and forward 3 trials should not be deivant
			bool have_deviant_forward_backward = false;
			int num_backward_forward = setting_deviant_min_trial_apart;
			loop int j = 1 until j > num_backward_forward begin
				if insert_position + j <= setting_interval_in_block then # check whether it is out of bound
					if whether_deviant[insert_position + j] == 1 then
						have_deviant_forward_backward = true;
						break;
					end;
				end;
				
				if insert_position - j >= 1 then # check whether it is out of bound
					if whether_deviant[insert_position - j] == 1 then
						have_deviant_forward_backward = true;
						break;
					end;
				end; 
				
				j = j + 1;
			end;#end of looping backward / forward
			
			if whether_deviant[insert_position] == 0 && have_deviant_forward_backward == false then 
				int insert_target_stim_index = index_of_whole_block[insert_position]; # get which stimulus this trial is
				# check the counter array to see whether this stim not yet exceed maximum deviant num
				if counter_deviant[insert_target_stim_index] < max_time_being_deviant then
					whether_deviant[insert_position] = 1;
					counter_deviant[insert_target_stim_index] = counter_deviant[insert_target_stim_index] +1;
					insert_successful = true;
				end; # end of if the stim not yet exceed max time
			end; # end of if position is 0
		end;
		
		i = i + 1;
	end;

	stim_list[1] = index_of_whole_block;
	stim_list[2] = whether_deviant;
	
	term.print_line(counter_deviant);
	
	return(stim_list);
end; # END OF assignDeviant


# create the list of stimuli of all trials in this block according to the regular_cond and interval_cond
# regular_cond (1: regular, 2: irregular)
# interval_cond (1, 2, 4, 16)
sub
	array<int,1> getBlockStimList(int regular_cond, int interval_cond)
begin
	# initialize a result variable
	array <int> stim_index_of_whole_block[0];

	# get the according regular order list based on the condition
	array <int> regular_order_list[0];
	if interval_cond == 1 then
		regular_order_list.append(order_1intervals);
	end;
	if interval_cond == 2 then
		regular_order_list.append(order_2intervals);
	end;
	if interval_cond == 4 then
		regular_order_list.append(order_4intervals);
	end;
	if interval_cond == 16 then
		regular_order_list.append(order_16intervals);
	end;

	if regular_cond == 1 then
		loop int i = 1 until i > (setting_interval_in_block / interval_cond) begin # the sequence will repeat for [480 / 4 intervals] times
			stim_index_of_whole_block.append(regular_order_list);
			i = i+1;
		end;
	end; # END OF regular_cond==1

	# for irregular condition, the same pattern should not repeat more than 3 times (3 time is allowed)
	if regular_cond == 2 then

		# initialize variable for checking
		array <int> last_sequence[0];
		int same_pattern_counter = 1;

		loop int i = 1 until i > (setting_interval_in_block / interval_cond) begin
			array <int> this_sequence[] = regular_order_list;
			this_sequence.shuffle();

			if last_sequence.count() != 0 && this_sequence == last_sequence then
				same_pattern_counter = same_pattern_counter + 1;
				if same_pattern_counter > setting_maximum_same_pattern then
					loop until this_sequence != last_sequence begin
						this_sequence.shuffle();
					end;
					same_pattern_counter = 1;
				end;

			else
				same_pattern_counter = 1;
			end;
			#term.print(same_pattern_counter);term.print(",");

			stim_index_of_whole_block.append(this_sequence);

			last_sequence.assign(this_sequence);
			i = i + 1;
		end;
	end; # END of regular_cond == 2

	return(stim_index_of_whole_block);

end;


# a routine to set the sound stimulus in each trial
# it will also return the wav file duration
sub 
	double setSoundStim(int deviant_cond, array<sound,1> normal_sound, array<sound,1> rotate_sound, int stim_id, int is_deviant) 
begin
	
	# should always be active so that false alarm / hit can be recorded
	
	sound the_stim;

	# rotate as deviant
	if deviant_cond == 1 && is_deviant == 0 then
		the_stim = normal_sound[stim_id];
	end;
	if deviant_cond == 1 && is_deviant == 1 then
		the_stim = rotate_sound[stim_id]
	end;

	# rotate as normal
	if deviant_cond == 2 && is_deviant == 0 then
		the_stim = rotate_sound[stim_id]
	end;
	if deviant_cond == 2 && is_deviant == 1 then
		the_stim = normal_sound[stim_id];
	end;

	sound_event.set_stimulus(the_stim);
	sound_event.set_target_button(is_deviant); # when it is not deviant, the target button should set to 0; when it is deviant, target button set to 1;
	if is_deviant == 1 then
		sound_event.set_stimulus_time_in(setting_response_window_start);
		sound_event.set_stimulus_time_out(setting_response_window_end);
	end;

	return(the_stim.get_wavefile().duration())

end;


# the routine to run the block given different conditions
sub
	runBlock(int deviant_cond, int regular_cond, int interval_cond)
begin

	##### Things to set before the whole block starts #####
	array <int> this_block_stim_list[] = getBlockStimList(regular_cond, interval_cond);
	array <int> this_block_stim_deviant[][] = assignDeviant(interval_cond, this_block_stim_list);

	# Find the according sound files of this interval_cond
	array <sound> normal_sound[0];
	array <sound> rotate_sound[0];
	if interval_cond == 1 then normal_sound.assign(soundfiles_1intervals); rotate_sound.assign(soundfiles_1intervals_rotated); end;
	if interval_cond == 2 then normal_sound.assign(soundfiles_2intervals); rotate_sound.assign(soundfiles_2intervals_rotated); end;
	if interval_cond == 4 then normal_sound.assign(soundfiles_4intervals); rotate_sound.assign(soundfiles_4intervals_rotated); end;
	if interval_cond == 16 then normal_sound.assign(soundfiles_16intervals); rotate_sound.assign(soundfiles_16intervals_rotated); end;

	##### END OF Things to set before the whole block starts #####

	# loop through trials
	loop int i = 1 until i > this_block_stim_list.count() begin
		double wav_file_duration = setSoundStim(deviant_cond, normal_sound, rotate_sound, this_block_stim_deviant[1][i], this_block_stim_deviant[2][i]);
		sound_event.set_event_code("test;"+string(this_block_stim_deviant[1][i]) + ";" + string(wav_file_duration) +";main;" + string(deviant_cond) + ";" + string(regular_cond)+";"+string(interval_cond)+";"+string(this_block_stim_deviant[2][i]));
		sound_trial.present();
		i = i + 1;
	end; 
	

end;